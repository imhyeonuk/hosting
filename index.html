
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>Kakao 지도 시작하기</title>
</head>
<body>
    <div id="map" style="width:500px;height:400px;"></div>
    <script type="text/javascript" src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=e17b255a81f15150d802f2e57887f807 "></script>
    <script>
        var container = document.getElementById('map');
        var options = {
            center: new kakao.maps.LatLng(35.132796, 129.106934),
            level: 3
        };

        var map = new kakao.maps.Map(container, options);
        var polylinePath = [];
        var polyline = new kakao.maps.Polyline({
            map: map,
            path: polylinePath,
            strokeWeight: 5,
            strokeColor: '#FF0000',
            strokeOpacity: 0.7,
            strokeStyle: 'solid'
        });

   // SVG arrow
   var arrowContent = '<div id="arrow" style="transform:rotate(0deg);"><svg width="30" height="30" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="#0000FF"><path d="M12 2L7 9h10L12 2zm0 3.82L13.74 9h-3.48L12 5.82zM7 11v2h10v-2H7zm0 4v6h10v-6H7z"/></svg></div>';

var customOverlay = new kakao.maps.CustomOverlay({
    map: map,
    content: arrowContent,
    position: map.getCenter(),
    yAnchor: 1
});

        function updatePosition(position) {
            var lat = position.coords.latitude,
                lon = position.coords.longitude;
            var newPoint = new kakao.maps.LatLng(lat, lon);

            if (polylinePath.length > 0) {
            var lastPoint = polylinePath[polylinePath.length - 1];
            var bearing = calculateBearing(lastPoint, newPoint);
            // Update the arrow direction
            var arrow = document.getElementById('arrow');
            arrow.style.transform = 'rotate(' + bearing + 'deg)';
        }

        polylinePath.push(newPoint);
        polyline.setPath(polylinePath);
        map.setCenter(newPoint);
        customOverlay.setPosition(newPoint);
    }

        function calculateBearing(startPoint, endPoint) {
            var startLat = radians(startPoint.getLat());
            var startLng = radians(startPoint.getLng());
            var destLat = radians(endPoint.getLat());
            var destLng = radians(endPoint.getLng());

            var y = Math.sin(destLng - startLng) * Math.cos(destLat);
            var x = Math.cos(startLat) * Math.sin(destLat) -
                    Math.sin(startLat) * Math.cos(destLat) * Math.cos(destLng - startLng);
            var bearing = Math.atan2(y, x);
            bearing = degrees(bearing); // Convert to degrees
            bearing = (bearing + 360) % 360; // Adjust to 0-360 if needed
            return bearing;
        }

        function radians(degrees) {
            return degrees * (Math.PI / 180);
        }

        function degrees(radians) {
            return radians * (180 / Math.PI);
        }

        function handleError(error) {
            console.warn(`ERROR(${error.code}): ${error.message}`);
        }

        if (navigator.geolocation) {
            navigator.geolocation.watchPosition(updatePosition, handleError, {
                enableHighAccuracy: true,
                timeout: 5000,
                maximumAge: 0
            });
        } else {
            alert("Geolocation is not supported by this browser.");
        }
    </script>
</body>
</html>
